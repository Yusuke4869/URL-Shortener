# コーディング原則

## 概要

このドキュメントは、プロジェクトで使用するコーディング原則と慣例を定義します。
これらの原則により、コードの一貫性、可読性、保守性を確保し、チーム間の効率的な協働を実現します。

## 命名原則

### 意味のある名前の使用

**What**: コードの意図を明確に表現する命名

**Why**:

- コードの可読性向上
- メンテナンスコストの削減
- 新しいメンバーの理解促進

**原則**:

- 目的を明確に表現する名前
- 略語や暗号的な名前を避ける
- コンテキストに応じた適切な詳細レベル
- 一貫した語彙の使用

### 命名規則の統一

**What**: 統一された命名パターンの採用

**Why**:

- コードの一貫性確保
- 認知負荷の軽減
- チーム間の理解統一

**規則**:

- **クラス・インターフェース**: PascalCase
- **メソッド・変数**: camelCase
- **定数**: SCREAMING_SNAKE_CASE
- **ファイル**: kebab-case
- **ディレクトリ**: 単数形を使用（`controller/`, `domain/` など）

## 関数設計原則

### 単一責任の原則

**What**: 1つの関数は1つの責任のみを持つ

**Why**:

- 理解しやすさの向上
- テストしやすさの確保
- 再利用性の向上
- デバッグの容易さ

**実装指針**:

- 関数名が動作を正確に表現している
- 引数の数を適切に制限
- 副作用の最小化
- 戻り値の型の明確性

### 純粋関数の優先

**What**: 入力に対して常に同じ出力を返し、副作用を持たない関数

**Why**:

- 予測可能な動作
- テストの容易さ
- 並行処理での安全性
- デバッグの簡素化

**実装指針**:

- 外部状態に依存しない
- 引数の変更を行わない
- グローバル変数の使用を避ける
- 例外処理の適切な設計

### アロー関数の採用

**What**: クラス以外の関数はアロー関数を使用する

**Why**:

- 関数型プログラミングの一貫性
- モダンな JavaScript/TypeScript 記法
- より簡潔な構文
- this バインディングの明確性

**実装指針**:

- export する関数は `export const functionName = () =>` 形式
- 内部関数も `const functionName = () =>` 形式
- async 関数は `const functionName = async () =>` 形式
- クラスメソッドは従来の `methodName()` 形式を維持

## 変数とデータ設計

### 不変性の重視

**What**: データの変更を制限する設計

**Why**:

- 予期しない変更の防止
- 並行処理での安全性
- デバッグの簡素化
- 副作用の最小化

**実装原則**:

- デフォルトで const を使用
- 必要な場合のみ let を使用
- var の使用を避ける
- オブジェクトの不変性を保つ

### 型安全性の確保

**What**: 型システムを活用した安全なコード

**Why**:

- 実行時エラーの予防
- コードの意図の明確化
- リファクタリングの安全性
- 開発効率の向上

**実装指針**:

- 明示的な型注釈の使用
- any 型の使用を避ける
- 型ガードの活用
- インターフェースによる契約の明確化

### 型キャストの排除

**What**: `as` による型キャストを避け、型安全な設計を採用

**Why**:

- 実行時の型安全性の確保
- 予期しないランタイムエラーの防止
- より明示的で理解しやすいコード
- TypeScript の型システムの恩恵を最大化

**実装指針**:

- 関数の引数で明示的に型を定義
- union 型を活用した型安全なパラメータ設計
- インターフェースによる構造化されたデータの受け渡し
- 型アサーションが必要な場合は設計の見直しを検討

## エラーハンドリング原則

### 適切な例外処理

**What**: エラー状況の明示的な処理

**Why**:

- システムの安定性向上
- デバッグ情報の充実
- ユーザー体験の改善
- システム全体の信頼性確保

**設計原則**:

- 具体的で意味のある例外の使用
- 適切なレベルでの例外キャッチ
- エラー情報の適切な伝播
- 回復可能性の考慮

## コード構成原則

### モジュール設計

**What**: 責任に基づいた適切なモジュール分割

**Why**:

- 関心事の分離
- 再利用性の向上
- テストの容易さ
- 保守性の確保

**設計指針**:

- 高い内部結合と低い外部結合
- 明確なインターフェースの定義
- 循環依存の回避
- 適切な抽象化レベル

### 簡潔性の原則

**What**: 不要な抽象化や中間レイヤーを排除し、直接的な実装を採用

**Why**:

- コードの理解しやすさの向上
- 保守コストの削減
- デバッグの容易さ
- 開発効率の向上

**設計指針**:

- 単純なケースでは直接インスタンス化を採用
- 型定義ファイルは複数の型がある場合のみ分離
- 中間インターフェースは実際に複数実装がある場合のみ作成
- 過度な抽象化を避けて理解しやすさを重視

### インポート管理

**What**: 依存関係の明確な管理

**原則**:

- 標準ライブラリを最初に
- サードパーティライブラリを次に
- 内部モジュールを最後に
- 使用しないインポートの削除

## コメントとドキュメント

### 意味のあるコメント

**What**: コードの意図を説明するコメント

**Why**:

- コードの理解促進
- 保守性の向上
- 知識の共有
- 複雑なロジックの説明

**原則**:

- コードが何をしているかではなく、なぜしているかを説明
- 複雑なビジネスロジックの背景を記述
- 設計判断の理由を記録
- 今後の改善点や注意点を明記

## セキュリティ考慮事項

### セキュアコーディング

**What**: セキュリティを考慮したコード実装

**Why**:

- セキュリティ脆弱性の防止
- データ保護の確保
- システム全体の安全性向上

**実装原則**:

- 入力データの適切な検証
- 機密情報の適切な取り扱い
- SQL インジェクション等の攻撃への対策
- 最小権限の原則の適用

## テスタビリティ

### テスト可能な設計

**What**: テストしやすいコード構造

**Why**:

- 品質の継続的な保証
- リファクタリングの安全性
- 仕様の文書化としての役割

**設計原則**:

- 依存関係の注入
- 副作用の分離
- モックしやすいインターフェース
- テストデータの独立性

## 継続的改善

### リファクタリング

**What**: コードの外部動作を変えずに内部構造を改善

**Why**:

- コード品質の継続的向上
- 技術的負債の解消
- 保守性の確保

**実践原則**:

- 小さな変更の積み重ね
- テストによる安全性の確保
- コードレビューによる品質確認
- 定期的な見直し

## コーディング品質チェックリスト

新しいコード実装や既存コード変更時の確認事項：

### 命名

- [ ] 変数・関数・クラス名が意図を明確に表現している
- [ ] 統一された命名規則に従っている
- [ ] ディレクトリ名が単数形で統一されている
- [ ] 略語や暗号的な名前を使用していない
- [ ] 一貫した語彙を使用している

### 関数設計

- [ ] 各関数が単一の責任を持っている
- [ ] 純粋関数として設計できる箇所は純粋関数にしている
- [ ] 関数の引数が適切な数に制限されている
- [ ] 戻り値の型が明確に定義されている
- [ ] クラス以外の関数でアロー関数を採用している

### データ設計

- [ ] 可能な限り不変性を保っている
- [ ] 適切な型注釈を提供している
- [ ] any 型の使用を避けている
- [ ] 型安全性を確保している
- [ ] 型キャスト（as）を排除し、型安全な設計を採用している
- [ ] union 型を活用した明示的な型定義を行っている

### エラーハンドリング

- [ ] 適切な例外処理を実装している
- [ ] エラー情報が十分に提供されている
- [ ] 例外の適切なレベルでの処理を行っている
- [ ] 回復可能性を考慮している

### コード構成

- [ ] 適切なモジュール分割ができている
- [ ] インポートが整理されている
- [ ] 循環依存が発生していない
- [ ] 高い内部結合・低い外部結合を実現している

### 簡潔性

- [ ] 不要な抽象化レイヤーを排除している
- [ ] 過度な抽象化を避けて理解しやすさを重視している
- [ ] 中間インターフェースを実際に複数実装がある場合のみ作成している
- [ ] 直接的で理解しやすい実装を採用している

### 可読性

- [ ] コードの意図が明確に表現されている
- [ ] 適切なコメントが記述されている
- [ ] 複雑なロジックが適切に説明されている
- [ ] コードスタイルが一貫している

### テスタビリティ

- [ ] 単体テストが書きやすい構造になっている
- [ ] 依存関係が適切に分離されている
- [ ] モックが作成しやすい設計になっている
- [ ] テストデータの独立性が保たれている

### セキュリティ

- [ ] 入力データの適切な検証を行っている
- [ ] 機密情報の適切な取り扱いができている
- [ ] セキュリティ脆弱性を考慮している
- [ ] 最小権限の原則を適用している
